# 📚 알고리즘 13일차

## 📌 깊이우선탐색(DFS, Depth-First Search)
```python
1. 그래프 탐색 알고리즘
  지난 시간에 그래프 데이터 구조에 대해 학습하였다.
  데이터 구조는 알고리즘의 재료가 되어 '문제를 해결'하는데 사용된다. 그렇다면 그래프 데이터 구조는 어떤 알고리즘에 활용할 수 있을까?

  # 그래프 탐색 알고리즘
  : 시작 정점에서 '간선을 타고 이동할 수 있는 
    모든 정점을 찾는' 알고리즘

  그래프 탐색 알고리즘에는 깊이우선탐색과 너비우선탐색이 있다. 이전에 학습했던 스택과 큐 자료구조의 개념을 함꼐 활용한다.

  # 스택 + 그래프 + 큐 
  - 깊이우선탐색(DFS, Depth-First Search)
  그래프의 깊이를 우선으로 탐색하기 위해 
  '스택'의 개념을 활용한다. # 스택 + 그래프

  - 너비우선탐색(BFS, B-First Search)
  그래프의 넓이를 우선으로 탐색하기 위해
  '큐'의 개념을 활용한다. # 그래프 + 큐

2. 깊이우선탐색(DFS)
: 시작정점으로부터 '갈 수 있는 하위 정점까지 가장 깊게 
  탐색'하고 더 이상 갈 곳이 없다면 마지막 갈림길로
  돌아와서 다른 정점을 탐색하며 결국 모든 정점을 
  방문하는 순회 방법

  깊이우선탐색(DFS)을 미로 탈출로 생각하면 이해하기 쉽다.
  '어느 한 쪽 길로 가장 깊게 들어갔다가 막히면 다시 
  돌아와서 다른 길을 탐색'한다.

# 깊이우선탐색(DFS)의 특징
  - '모든 정점을 방문'할 때 유리하다. 따라서
    '경우의 수, 순열과 조합'문제에서 많이 사용한다.
  - 너비우선탐색(BFS)에 비해 코드 구현이 간단하다.
  - 단, 모든 정점을 방문할 필요가 없거나 최단 거리를
    구하는 경우에는 너비우선탐색(BFS)이 유리하다.

3. DFS의 동작 과정
  DFS를 하기 전에, 일단 탐색을 진행할 그래프가 필요하다.
  그래프는 '인접 행렬' 혹은 '인접 리스트' 방식으로 표현할 수 있다.

  '각 정점을 방문했는지 여부를 판별'할 방문체크리스트가 필요하다.
  사람과 달리 컴퓨터는 각 정점에 도달했는지 여부를 알 수 없다.
  따라서 visited 리스트를 따로 선언하여 각 정점을 방문했는지 체크한다.

  # DFS의 사이클
    1) 현재 정점 방문처리
    2) 인접한 모든 정점 확인
    3) 방문하지 않은 인접 정점 이동

4. DFS의 구현 방식
  지금까지 살펴본 DFS를 코드로 구현해보자.
  여기에서는 '인접 리스트'로 표현한 그래프를 기준으로 설명한다.

  # 반복문을 이용한 DFS
  DFS는 직전에 방문한 정점으로 차례로 돌아가야 하므로, 
  후입선출(FIFO)구조의 '스택'을 사용한다.

  graph = [
    [1,2],
    [0,3,4],
    [0,4,5],
    [1],
    [1,2,6],
    [2],
    [4]
  ]

  visited = [False] * n # 방문 처리 리스트 만들기

  visited[start] = True # 시작 정점 방문 처리 
  stack = [start] # 돌아갈 곳을 기록

  # 스택이 빌 때까지(돌아갈 곳이 없을 때까지) 반복
  while len(stack) != 0: 
    cur = stack.pop() # 현재 방문 정점(후입선출)

    for adj in graph[cur] # 인접한 모든 정점에 대해
      if not visited[adj] # 아직 방문하지 않았다면
        visited[adj] = True # 방문처리
        stack.append(adj) # 스택에 인입

5. DFS 문제 풀이
  1) 입력 값을 받아 인접 리스트를 생성
  2) 1번 컴퓨터를 시작 정점으로 DFS 진행

6. 이차원 격자에서의 DFS

  

```

## 📌
```python

```

## 📌
```python

```